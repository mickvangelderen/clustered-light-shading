use clap::{App, Arg};
use std::fs::File;
use std::io::{BufReader, Write};
use std::path::Path;

use renderer::profiling::*;
use renderer::*;

fn read_events(path: impl AsRef<Path>) -> std::io::Result<Vec<MeasurementEvent>> {
    let mut file = BufReader::new(File::open(path)?);

    let mut events = Vec::new();

    loop {
        match bincode::deserialize_from::<_, MeasurementEvent>(&mut file) {
            Ok(event) => events.push(event),
            Err(error) => {
                // Unbox error.
                match *error {
                    bincode::ErrorKind::Io(error) => match error.kind() {
                        std::io::ErrorKind::UnexpectedEof => {
                            // This is what we expect.
                            break;
                        }
                        other => panic!(other),
                    },
                    other => {
                        panic!(other);
                    }
                }
            }
        }
    }

    Ok(events)
}

fn main() {
    let _matches = App::new("Profiling Reader")
        .version("1.0")
        .author("Mick van Gelderen")
        .about("Reads profiling information from logs generated by renderer.")
        .arg(
            Arg::with_name("sample")
                .help("Print data for a sample index")
                .required(false)
                .index(1),
        )
        .get_matches();

    let current_dir = std::env::current_dir().unwrap();
    let base_profiling_dir = current_dir.join("profiling");
    let latest_profiling_dir = base_profiling_dir.join("latest");
    let current_profiling_dir =
        std::fs::read_link(latest_profiling_dir).expect("Didn't find symlink to latest profiling directory.");
    dbg!(&current_profiling_dir);
    let configuration_path = current_profiling_dir.join("configuration.toml");
    let cfg = Configuration::read(&configuration_path);
    let profiling_path = current_profiling_dir.join(cfg.profiling.path.as_ref().unwrap());

    let events = read_events(profiling_path).unwrap();

    let mut sample_names = Vec::new();
    let mut max_run_index = None;
    let mut max_frame_index = None;
    let mut max_cluster_buffer_count = None;
    let mut max_basic_buffer_count = None;

    fn option_max_assign<T: Copy + std::cmp::Ord>(o: &mut Option<T>, v: T) {
        *o = match *o {
            Some(o) => Some(o.max(v)),
            None => Some(v),
        }
    }

    let mut cluster_buffer_count = 0;
    let mut basic_buffer_count = 0;

    for event in events.iter() {
        match *event {
            MeasurementEvent::BeginRun(run_index) => {
                option_max_assign(&mut max_run_index, run_index.to_usize());
            }
            MeasurementEvent::BeginFrame(frame_index) => {
                option_max_assign(&mut max_frame_index, frame_index.to_usize());
                cluster_buffer_count = 0;
                basic_buffer_count = 0;
            }
            MeasurementEvent::EndFrame => {
                option_max_assign(&mut max_cluster_buffer_count, cluster_buffer_count);
                option_max_assign(&mut max_basic_buffer_count, basic_buffer_count);
            }
            MeasurementEvent::SampleName(index, ref name) => {
                assert_eq!(index.to_usize(), sample_names.len());
                sample_names.push(name.clone());
            }
            MeasurementEvent::RecordClusterBuffer(ref _cluster_buffer) => {
                cluster_buffer_count += 1;
            }
            MeasurementEvent::RecordBasicBuffer(ref _basic_buffer) => {
                basic_buffer_count += 1;
            }
            _ => {}
        }
    }

    let run_count = max_run_index.map(|index| index + 1).unwrap_or(0);
    let frame_count = max_frame_index.map(|index| index + 1).unwrap_or(0);
    let sample_count = sample_names.len();
    let cluster_buffer_count = max_cluster_buffer_count.unwrap_or(0);
    let basic_buffer_count = max_basic_buffer_count.unwrap_or(0);

    dbg!(&sample_names);
    dbg!(sample_count);
    dbg!(run_count);
    dbg!(frame_count);
    dbg!(cluster_buffer_count);
    dbg!(basic_buffer_count);

    let sample_stride = 4;
    let frame_stride = sample_count * sample_stride;
    let run_stride = frame_count * frame_stride;
    let u64_count = run_count * run_stride;
    let mut flat_samples: Vec<u64> = std::iter::repeat(std::u64::MAX).take(u64_count).collect();
    let mut flat_cluster_buffers: Vec<ClusterBuffer> = std::iter::repeat_with(Default::default)
        .take(frame_count * cluster_buffer_count)
        .collect();
    let mut flat_basic_buffers: Vec<BasicBuffer> = std::iter::repeat_with(Default::default)
        .take(frame_count * basic_buffer_count)
        .collect();

    let mut run_index: Option<usize> = None;
    let mut frame_index: Option<usize> = None;
    let mut cluster_buffer_index = 0;
    let mut basic_buffer_index = 0;

    for event in events.iter() {
        match *event {
            MeasurementEvent::BeginRun(index) => {
                run_index = Some(index.to_usize());
            }
            MeasurementEvent::EndRun => {
                run_index = None;
            }
            MeasurementEvent::BeginFrame(index) => {
                frame_index = Some(index.to_usize());
                cluster_buffer_index = 0;
                basic_buffer_index = 0;
            }
            MeasurementEvent::EndFrame => {
                frame_index = None;
            }
            MeasurementEvent::BeginTimeSpan(sample_index, span) => {
                let base_index = run_index.unwrap() * run_stride
                    + frame_index.unwrap() * frame_stride
                    + sample_index.to_usize() * sample_stride;
                flat_samples[base_index + 0] = span.cpu.begin;
                flat_samples[base_index + 1] = span.cpu.end;
                flat_samples[base_index + 2] = span.gpu.begin;
                flat_samples[base_index + 3] = span.gpu.end;
            }
            MeasurementEvent::RecordClusterBuffer(ref cluster_buffer) => {
                assert_eq!(run_index, Some(0));
                flat_cluster_buffers[frame_index.unwrap() * cluster_buffer_count + cluster_buffer_index] =
                    cluster_buffer.clone();
                cluster_buffer_index += 1;
            }
            MeasurementEvent::RecordBasicBuffer(ref basic_buffer) => {
                assert_eq!(run_index, Some(0));
                flat_basic_buffers[frame_index.unwrap() * basic_buffer_count + basic_buffer_index] =
                    basic_buffer.clone();
                basic_buffer_index += 1;
            }
            _ => {}
        }
    }

    let samples_path = current_profiling_dir.join("samples.bin");
    let mut file = std::io::BufWriter::new(std::fs::File::create(samples_path).unwrap());

    #[allow(unused)]
    struct H {
        run_count: u64,
        frame_count: u64,
        sample_count: u64,
        cluster_buffer_count: u64,
        basic_buffer_count: u64,
    };

    file.write_all(
        H {
            run_count: run_count as u64,
            frame_count: frame_count as u64,
            sample_count: sample_count as u64,
            cluster_buffer_count: cluster_buffer_count as u64,
            basic_buffer_count: basic_buffer_count as u64,
        }
        .value_as_bytes(),
    )
    .unwrap();

    for name in sample_names.iter() {
        let bytes = name.as_bytes();
        let count = bytes.len() as u64;
        file.write(&count.to_ne_bytes()).unwrap();
        file.write(bytes).unwrap();
        const ZEROS: [u8; 8] = [0; 8];
        if (count % 8) != 0 {
            file.write(&ZEROS[0..(8 - (count % 8)) as usize]).unwrap();
        }
    }

    file.write_all(flat_samples.vec_as_bytes()).unwrap();
    file.write_all(flat_cluster_buffers.vec_as_bytes()).unwrap();
    file.write_all(flat_basic_buffers.vec_as_bytes()).unwrap();
}
