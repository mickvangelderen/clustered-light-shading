use clap::{App, Arg, SubCommand};
use std::fs::File;
use std::io::{BufReader, Write};
use std::path::{Path, PathBuf};

use renderer::profiling::*;
use renderer::*;

fn get_config() -> Configuration {
    let current_dir = std::env::current_dir().unwrap();
    let resource_dir: PathBuf = [current_dir.as_ref(), Path::new("resources")].into_iter().collect();
    let configuration_path = resource_dir.join(Configuration::DEFAULT_PATH);
    Configuration::read(&configuration_path)
}

fn read_events(path: impl AsRef<Path>) -> std::io::Result<Vec<MeasurementEvent>> {
    let mut file = BufReader::new(File::open(path)?);

    let mut events = Vec::new();

    loop {
        match bincode::deserialize_from::<_, MeasurementEvent>(&mut file) {
            Ok(event) => events.push(event),
            Err(error) => {
                // Unbox error.
                match *error {
                    bincode::ErrorKind::Io(error) => match error.kind() {
                        std::io::ErrorKind::UnexpectedEof => {
                            // This is what we expect.
                            break;
                        }
                        other => panic!(other),
                    },
                    other => {
                        panic!(other);
                    }
                }
            }
        }
    }

    Ok(events)
}

fn main() {
    let matches = App::new("Profiling Reader")
        .version("1.0")
        .author("Mick van Gelderen")
        .about("Reads profiling information from logs generated by renderer.")
        .arg(
            Arg::with_name("sample")
                .help("Print data for a sample index")
                .required(false)
                .index(1),
        )
        .get_matches();

    let cfg = get_config();

    let events = read_events(cfg.profiling.path.as_ref().unwrap()).unwrap();

    let mut sample_names = Vec::new();
    let mut max_run_index = None;
    let mut max_frame_index = None;

    fn option_max_assign<T: Copy + std::cmp::Ord>(o: &mut Option<T>, v: T) {
        *o = match *o {
            Some(o) => {
                Some(o.max(v))
            },
            None => {
                Some(v)
            }
        }
    }

    for event in events.iter() {
        match *event {
            MeasurementEvent::BeginRun(run_index) => {
                option_max_assign(&mut max_run_index, run_index.to_usize());
            }
            MeasurementEvent::BeginFrame(frame_index) => {
                option_max_assign(&mut max_frame_index, frame_index.to_usize());
            }
            MeasurementEvent::SampleName(index, ref name) => {
                assert_eq!(index.to_usize(), sample_names.len());
                sample_names.push(name.clone());
            }
            _ => {}
        }
    }

    let run_count = max_run_index.unwrap() + 1;
    let frame_count = max_frame_index.unwrap() + 1;
    let sample_count = sample_names.len();

    dbg!(&sample_names);
    dbg!(sample_count);
    dbg!(run_count);
    dbg!(frame_count);

    let sample_stride = 4;
    let frame_stride = sample_count * sample_stride;
    let run_stride = frame_count * frame_stride;
    let u64_count = run_count * run_stride;
    let mut flat_samples: Vec<u64> = std::iter::repeat(std::u64::MAX).take(u64_count).collect();

    let mut run_index: Option<usize> = None;
    let mut frame_index: Option<usize> = None;

    for event in events.iter() {
        match *event {
            MeasurementEvent::BeginRun(index) => {
                run_index = Some(index.to_usize());
            }
            MeasurementEvent::EndRun => {
                run_index = None;
            }
            MeasurementEvent::BeginFrame(index) => {
                frame_index = Some(index.to_usize());
            }
            MeasurementEvent::EndFrame => {
                frame_index = None;
            }
            MeasurementEvent::BeginTimeSpan(sample_index, span) => {
                let base_index = run_index.unwrap() * run_stride
                    + frame_index.unwrap() * frame_stride
                    + sample_index.to_usize() * sample_stride;
                flat_samples[base_index + 0] = span.cpu.begin;
                flat_samples[base_index + 1] = span.cpu.end;
                flat_samples[base_index + 2] = span.gpu.begin;
                flat_samples[base_index + 3] = span.gpu.end;
            }
            _ => {}
        }
    }

    let mut file = std::io::BufWriter::new(std::fs::File::create("samples.bin").unwrap());

    struct H {
        run_count: u64,
        frame_count: u64,
        sample_count: u64,
    };

    file.write_all(
        H {
            run_count: run_count as u64,
            frame_count: frame_count as u64,
            sample_count: sample_count as u64,
        }
        .value_as_bytes(),
    )
    .unwrap();

    for name in sample_names.iter() {
        let bytes = name.as_bytes();
        let count = bytes.len() as u64;
        file.write(&count.to_ne_bytes()).unwrap();
        file.write(bytes);
        const ZEROS: [u8; 8] = [0; 8];
        if (count % 8) != 0 {
            file.write(&ZEROS[0..(8 - (count % 8)) as usize]);
        }
    }

    file.write_all(flat_samples.vec_as_bytes()).unwrap();
}
