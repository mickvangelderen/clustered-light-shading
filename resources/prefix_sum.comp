#line 1 1

#define LOCAL_XYZ (LOCAL_X) * (LOCAL_Y) * (LOCAL_Z)

layout(std430, binding = 0) buffer InputBuffer {
  uvec4 values[ITEM_COUNT >> 2];
}
ib;

layout(std430, binding = 1) buffer OutputBuffer {
  uvec4 values[ITEM_COUNT >> 2];
}
ob;

shared uvec4 values[LOCAL_XYZ];

layout(local_size_x = LOCAL_X, local_size_y = LOCAL_Y,
       local_size_z = LOCAL_Z) in;

uvec4 scan_uvec4(uvec4 v) {
  v += uvec4(0, v.xyz);
  v += uvec4(0, 0, v.xy);
  return v;
}

void sum_2(uint i, uint s) {
  uvec4 acc = values[i] + uvec4((i >= s) ? values[i - s].w : 0);
  memoryBarrierShared();
  barrier();

  values[i] = acc;
  memoryBarrierShared();
  barrier();
}

void main() {
  uint i = gl_LocalInvocationIndex;

  // simple copy implementation. sanity check.
  // ob.values[gl_WorkGroupID.x * LOCAL_XYZ + i] = ib.values[gl_WorkGroupID.x *
  // LOCAL_XYZ + i];

  // Move input to shared memory.
  values[i] = scan_uvec4(ib.values[gl_WorkGroupID.x * LOCAL_XYZ + i]);
  memoryBarrierShared();
  barrier();

  // Compute prefix sum.
#if (1 << 0) < LOCAL_XYZ
  sum_2(i, 1 << 0);
#endif
#if (1 << 1) < LOCAL_XYZ
  sum_2(i, 1 << 1);
#endif
#if (1 << 2) < LOCAL_XYZ
  sum_2(i, 1 << 2);
#endif
#if (1 << 3) < LOCAL_XYZ
  sum_2(i, 1 << 3);
#endif
#if (1 << 4) < LOCAL_XYZ
  sum_2(i, 1 << 4);
#endif
#if (1 << 5) < LOCAL_XYZ
  sum_2(i, 1 << 5);
#endif
#if (1 << 6) < LOCAL_XYZ
  sum_2(i, 1 << 6);
#endif
#if (1 << 7) < LOCAL_XYZ
  sum_2(i, 1 << 7);
#endif
#if (1 << 8) < LOCAL_XYZ
  sum_2(i, 1 << 8);
#endif
#if (1 << 9) < LOCAL_XYZ
  sum_2(i, 1 << 9);
#endif
#if (1 << 10) < LOCAL_XYZ
#error Loop insufficiently unrolled.
#endif

  // Emit output from shared memory.
  ob.values[gl_WorkGroupID.x * LOCAL_XYZ + i] = values[i];
}
