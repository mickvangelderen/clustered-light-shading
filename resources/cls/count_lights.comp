#include "cls.glsl"
#include "../common.glsl"

#define tid gl_LocalInvocationID.x
#define wid gl_WorkGroupID.x
#define LOCAL_X 128

layout(location = 0) uniform uvec3 cluster_dims;
layout(location = 1) uniform vec3 scale_from_cls_to_hmd;
layout(location = 2) uniform vec3 trans_from_cls_to_hmd;
layout(location = 3) uniform uint light_count;

layout(local_size_x = LOCAL_X) in;

uint uint_div_ceil(uint n, uint d) {
  uint r = n / d;
  return ((n % d) == 0) ? r : r + 1;
}

void main() {
  uint cluster_index = active_cluster[wid];
  uvec3 idx_in_cls = index_1_to_3(cluster_index, cluster_dims);
  vec3 p0 = vec3(idx_in_cls) * scale_from_cls_to_hmd + trans_from_cls_to_hmd;
  vec3 p1 = vec3(idx_in_cls + uvec3(1)) * scale_from_cls_to_hmd + trans_from_cls_to_hmd;

  uint intersection_count = 0;
  for (uint light_base = 0; light_base < light_count; light_base += LOCAL_X) {
    vec4 light = light_xyzr[light_base + tid];
    float d = 0;
    if (light.x < p0.x) {
      d += (p0.x - light.x) * (p0.x - light.x);
    } else if (p1.x <= light.x) {
      d += (light.x - p1.x) * (light.x - p1.x);
    }
    if (light.y < p0.y) {
      d += (p0.y - light.y) * (p0.y - light.y);
    } else if (p1.y <= light.y) {
      d += (light.y - p1.y) * (light.y - p1.y);
    }
    if (light.z < p0.z) {
      d += (p0.z - light.z) * (p0.z - light.z);
    } else if (p1.z <= light.z) {
      d += (light.z - p1.z) * (light.z - p1.z);
    }
    if (d < light.w) {
      intersection_count += 1;
    }
  }

  if (d < light.w) {
    light_count[wid];
  }
}
