#include "../common.glsl"

layout(binding = 0) uniform sampler2D depth_sampler;
layout(location = 1) uniform vec2 fb_dims;
layout(location = 2) uniform mat4 clp_to_wld;
layout(location = 3) uniform mat4 wld_to_cls;
layout(location = 4) uniform uvec3 cluster_dims;

layout(binding = 0) buffer OutputBuffer { uint fragments_per_cluster[]; };

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
  if (any(greaterThan(gl_GlobalInvocationID.xy, fb_dims))) {
    // Out of texture bounds.
    return;
  }

  // pos_in_ndc is known.
  // inverse projection clp_to_cls is known.
  // assuming w_cls = 1, we can compute pos_in_cls.
  vec2 xy_ndc = vec2(ivec2(gl_GlobalInvocationID.xy) * 2 + 1 - ivec2(fb_dims)) / vec2(fb_dims);
  float z_ndc = texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), 0).r;

  if (z_ndc == 0) {
    // Infinitely far (reverse z)
    return;
  }

  vec4 pos_in_ndc = to_homogeneous(vec3(xy_ndc, z_ndc));
  vec3 pos_in_wld = from_homogeneous(clp_to_wld * pos_in_ndc);
  vec4 pos_in_cls_post = wld_to_cls * to_homogeneous(pos_in_wld);
  vec3 pos_in_cls = vec3(pos_in_cls_post.xy / vec2(pos_in_cls_post.w), pos_in_cls_post.z);

  uvec3 idx_in_cls = uvec3(pos_in_cls);
  if (all(lessThan(idx_in_cls, cluster_dims))) {
    uint cluster_index = index_3_to_1(idx_in_cls, cluster_dims);
    atomicAdd(fragments_per_cluster[cluster_index], 1);
  }
}
