#include "../common.glsl"

layout(location = 0) uniform sampler2D depth_sampler;
layout(location = 1) uniform vec2 fb_dims;
layout(location = 2) uniform mat4 clp_to_cls;
layout(location = 3) uniform uvec3 cluster_dims;

layout(binding = 0) buffer OutputBuffer { uint fragments_per_cluster[]; };

vec3 compute_pos_in_cls() {
  // pos_in_ndc is known.
  // inverse projection clp_to_cls is known.
  // assuming w_cls = 1, we can compute pos_in_cls.
  vec4 pos_in_ndc = to_homogeneous(vec3(
      // xy
      vec2(gl_GlobalInvocationID.xy) / fb_dims * 2.0 - vec2(1.0),
      // z
      texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), 0).r));
  return from_homogeneous(clp_to_cls * pos_in_ndc);
}

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
  uvec3 idx_in_cls = uvec3(compute_pos_in_cls());
  if (all(lessThan(gl_GlobalInvocationID.xy, fb_dims)) &&
      all(lessThan(idx_in_cls, cluster_dims))) {

    float z = texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), 0).r;

    uint cluster_index =
        index_3_to_1(uvec3(vec3(vec2(gl_GlobalInvocationID.xy) / fb_dims, z) *
                           vec3(cluster_dims)),
                     cluster_dims);
    // uint cluster_index = index_3_to_1(idx_in_cls, cluster_dims);
    atomicAdd(fragments_per_cluster[cluster_index], 1);
  }
}
