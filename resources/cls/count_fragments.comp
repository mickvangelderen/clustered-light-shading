#include "native/PREFIX_SUM"
#include "native/CLUSTERED_LIGHT_SHADING"

#include "../common.glsl"
#include "cluster_space_buffer.glsl"
#include "cluster_fragment_counts_buffer.glsl"

layout(binding = DEPTH_SAMPLER_LOC) uniform sampler2D depth_sampler;
layout(location = FB_DIMS_LOC) uniform vec2 fb_dims;
layout(location = CLP_TO_WLD_LOC) uniform mat4 clp_to_wld;

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
  if (any(greaterThan(gl_GlobalInvocationID.xy, fb_dims))) {
    // Out of texture bounds.
    return;
  }

  // pos_in_ndc is known.
  // inverse projection clp_to_cls is known.
  // assuming w_cls = 1, we can compute pos_in_cls.
  vec2 xy_ndc = vec2(ivec2(gl_GlobalInvocationID.xy) * 2 + 1 - ivec2(fb_dims)) / vec2(fb_dims);
  float z_ndc = texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), 0).r;

  if (z_ndc == 0) {
    // Infinitely far (reverse z)
    return;
  }

  vec4 pos_in_ndc = to_homogeneous(vec3(xy_ndc, z_ndc));
  vec3 pos_in_cam = from_homogeneous(cluster_space.wld_to_cam * clp_to_wld * pos_in_ndc);
  vec4 pos_in_clp = cluster_cam_to_clp(pos_in_cam);
  vec3 pos_in_cls = vec3(pos_in_clp.x / pos_in_clp.w, pos_in_clp.y / pos_in_clp.w, pos_in_clp.z);

  uvec3 idx_in_cls = uvec3(pos_in_cls);
  if (all(lessThan(idx_in_cls, cluster_space.dimensions))) {
    uint cluster_index = index_3_to_1(idx_in_cls, cluster_space.dimensions);
    atomicAdd(cluster_fragment_counts[cluster_index], 1);
  }
}
