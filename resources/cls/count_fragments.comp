#include "native/PREFIX_SUM"
#include "native/CLUSTERED_LIGHT_SHADING"

#include "../common.glsl"
#include "cluster_space_buffer.glsl"
#include "cluster_fragment_counts_buffer.glsl"

layout(binding = DEPTH_SAMPLER_LOC) uniform sampler2DMS depth_sampler;
layout(location = FB_DIMS_LOC) uniform vec2 fb_dims;
layout(location = CLP_TO_WLD_LOC) uniform mat4 clp_to_wld;

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
  if (any(greaterThan(gl_GlobalInvocationID.xy, fb_dims))) {
    // Out of texture bounds.
    return;
  }

  // pos_in_ndc is known.
  ivec2 depth_dims = textureSize(depth_sampler);
  vec2 xy_ndc = vec2(ivec2(gl_GlobalInvocationID.xy) * 2 + 1 - depth_dims) / vec2(depth_dims);
  for (int sample_index = 0; sample_index < 16; sample_index++) {
    float z_ndc = texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), sample_index).r;

    if (z_ndc == 0) {
      // Infinitely far (reverse z)
      return;
    }

    vec4 pos_in_ndc = to_homogeneous(vec3(xy_ndc, z_ndc));
    vec3 pos_in_ccam = from_homogeneous(cluster_space.wld_to_cam * clp_to_wld * pos_in_ndc);
    vec3 pos_in_cls = cluster_cam_to_cls(pos_in_ccam);

    uvec3 idx_in_cls = uvec3(pos_in_cls);
    if (all(lessThan(idx_in_cls, cluster_space.dimensions))) {
      uint cluster_index = index_3_to_1(idx_in_cls, cluster_space.dimensions);
      atomicAdd(cluster_fragment_counts[cluster_index], 1);
    }
  }
}
